# 代码规范（草案）beta 1

by: C.M.    2019.09.09



## 目录

### 第零部分 总论

### 第一部分 语法规范

一、头文件与源文件

二、 变量

​	2.1. 变量命名

​		2.1.1. 保留变量名

​		2.1.2. 一般命名

​		2.1.3. 前缀与后缀

​	2.2. 变量的使用

​		2.1.1. 全局变量

​		2.2.2. 静态变量

​		2.2.3. 局部变量

​		2.2.4. 指针与引用

​		2.2.5. 常量与宏

​		2.2.6. 枚举类型

​			2.2.6.1. 常量枚举

​			2.2.6.2. 标志位枚举

​	2.3. 变量注释

三、 表达式

四、 条件语句

五、 函数

​	5.1. 保留函数命名

六、 结构体与类

七、 预编译指令

八、 异常处理

### 第二部分 架构规范





## 总论

### 一、 Beta 1版本总论

建立完备的编码规则，有助于提高代码的可读性、可维护性、可移植性。代码规范，已经成为具有一定规模的开发团队的必需品。我认为，对于眼下规模的智能车社团，建立一套科学高效、易于遵守的代码规范，可以提高各队之间合作的效率，也便于进行技术交流与传承。基于以上考量，我开始着手制定本代码规范。

本规范的制定，参考了UNIX和GNU的代码规范，结合NXP MCUxpresso SDK中的代码，同时借鉴了本人了解的一些大型项目（包括但不仅限于U8glib、Amazon FreeRTOS）的代码。由于规范的制定免不了会受个人习惯和偏好的影响，可能会影响规范的科学性，因此也欢迎各位通过实践找出其中的不完善之处。

代码规范并不会让写代码变得更简单，恰恰相反，遵守代码规范在大多数时候都是一项令人恼火的负担。但这种所谓的负担，却在无形之中减少了了开发团队的内耗，降低了沟通成本，提高了合作的效率。无数的实践已经证明，高效的开发需要统一的标准。对于社团而言，代码规范的建立绝非一日之功，它需要各位的严格遵守，需要经年累月的不断完善，甚至可能需要几代智能车人的坚守。是时候放弃旧有的野蛮生长的代码方式了。我衷心的希望，在经历了转变的阵痛之后，智能车的开发会变得更加简单高效，我们将有机会在有限的时间内做到更多，智能车的未来可以成就更多辉煌。

根据计划，本代码规范包括两部分：语法规范和架构规范。语法规范主要包括了以下内容：

- 不同情况下该使用何种语法
- 各种语法元素在不同情况下的命名方式及注释内容

而架构规范主要包括：

- 工程架构应当如何分层
- 常见的功能模块应该如何书写
- 一些用于实现特定功能的固定结构形式（设计模式）

本代码规范将使用以下词汇描述对规范约束的严格程度：

- 必须：任何情况下都要这样做，须严格遵守。
- 应该：大多数情况下应该这样做，特殊情况在知晓其危害的前提下可以违背该规范。
- 推荐：建议的做法，不遵守该规范可能会使得代码的编写变得困难。
- 不推荐：不建议的做法，不遵守该规范可能会使得代码的编写变得困难。
- 避免：大多数情况下不应该这样做，特殊情况在知晓其危害的前提下可以违背该规范。
- 禁止：任何情况下都不要这样做，须严格遵守。

目前在编写的是第一部分。

C.M.@hit    2019.09.09











## 第一部分 语法规范

### 一、 头文件与源文件

#### 1.1. 文件规范

1. 文件命名以`所属层级`+`_`+`文件名主体`构成。有时还包括文件名后缀。

   > 示例1：
   >
   > ```C++
   > #include "rte_common.hpp"		//Runtime Environment Layer, common
   > #include "drv_pitmgr.hpp"		//System Driver Layer, PIT Manager
   > #include "drv_lcd_st7789.hpp"	//System Driver Layer, LCD Driver, Model "ST7789"
   > #include "app_ctrl.hpp"			//Application Layer, Controll
   > ```
   >
   > 具体的分层结构详见**“第二部分 架构规范”**。

2. 工程中的头文件（`*.h`、`*.hpp`）与源文件（`*.c`、`*.cpp`）推荐以相同文件名成对出现，其中头文件可以独立出现而不与源文件成对，而源文件禁止独立出现。所有文件均以小写命名，前缀和名称之间用下划线`_`分隔。

3. 包含C++代码的头文件和源文件，必须以`*.hpp`、`*.cpp`作为文件扩展名。

4. 多数情况下，源文件（`*.c`、`*.cpp`）中仅允许包含（`#include`）与自身同名的头文件（`*.h`、`*.hpp`），且C语言文件禁止包含含有C++代码的文件。极少数情况下，如果某个头文件中仅包含定义时即被初始化的变量，则源文件中可以包含这类头文件，但必须保证该头文件**仅在此源文件中包含一次**。

   > 示例1：
   > ```c++
   > /* appimg.hpp */
   > #pragma once
   > #include "include.h"	//general include
   > #include "drvcam.h"		//camera driver
   > 
   > //other code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* appimg_iptmap.hpp */
   > static uint8_t appimg_iptMap[IMG_IPT_R][IMG_IPT_C] = 
   > {
   > //here comes IMG_IPT_R * IMG_IPT_C numbers...  
   > };
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* appimg.cpp */
   > #pragma once
   > #include "appimg.hpp"
   > #include "appimg_iptmap.hpp"
   > 
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   > 上述代码演示了1.3叙述的规范。假设`appimg.hpp`与`appimg.cpp`是图像处理的头文件与源文件，而`appimg_iptmap.hpp`内存储了图像处理所需的逆透视矩阵。逆透视矩阵有数百行，上万个参数，由算法生成，如果直接放在`appimg.cpp`中，会占用大量空间。相信没有人会希望要查找代码时里面混杂着几百行全是数组初始化参数的文件，因此我们把这部分数据单独写在一个文件中。这样做的另一个原因是，如果我们希望修改该逆透视矩阵，可以在电脑上用C语言程序修改参数后，利用文件读写功能直接输出文件，然后直接替换，完全不需要编辑代码。但是，如果我们在一个文件中包含两次`appimg_iptmap.hpp`，则会出现重定义错误。因此，对此文件的包含仅能在appimg.cpp中出现一次，不可在其他地方再次包含。
   >
   > 这种情况还有另一个解决方案：
   >
   > 示例2：
   >
   > ```c++
   > /* appimg.hpp */
   > #pragma once
   > #include "include.h"	//general include
   > #include "drvcam.h"		//camera driver
   > #include "appimg_iptmap.hpp"
   > 
   > extern uint8_t appimg_iptMap[IMG_IPT_R][IMG_IPT_C]
   > //other code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* appimg_iptmap.cpp */
   > uint8_t appimg_iptMap[IMG_IPT_R][IMG_IPT_C] = 
   > {
   > //here comes IMG_IPT_R * IMG_IPT_C numbers...  
   > };
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* appimg.cpp */
   > #pragma once
   > #include "appimg.hpp"
   > 
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   >
   > 这违反了规范1.1，故应避免这种写法。

5. 推荐将所有经常包含的头文件分类放在2~3个头文件中，方便包含。推荐的方案为：一个头文件用于存放C语言标准库（如果是C++工程，需要两个头文件将标准库与C++标准库分开存放，避免C文件不小心包含了C++头文件导致无法找到头文件的错误），一个头文件用于存放NXP MCUXpresso SDK的头文件，一个头文件用于存放和开发平台无关的定义（如图像大小、PI等常量、常用的数据类型和数据结构定义等）。



#### 1.2. 格式规范

1. Pending： 文件头注释，代码块注释

   ```c++
   /* @BetaCat_Ctrl v2.1
    * @use: this is a simple demostration of File Comments.
    * @auth Chekhov
    * @date 2019.09.10
    * @v1.00
    */
   ```

2. Pending：空行 空格 。。。。。。







### 二、 变量

#### 2.1. 变量命名

##### 2.1.1. 保留变量名

1. 禁止使用`i`、`j`、`k`、`x`、`y`、`z`、`m`、`n`、`p`、`r`、`c`等具有数学含义、物理含义或现实意义的字母或单词作为全局变量名。
2. 禁止使用形如`aa`、`bbb`等毫无意义的名称作为变量名。
3. 避免使用形式常被用于系统保留的字符作为变量名，如全部大写（`NAME`）、首尾带下划线（`_name_`、`_name`、`name_`、`__name__`、`__name`、`name__`）。



##### 2.1.2. 一般命名

1. 全局变量命名采用`小写前缀`+ `_`+`Camel命名法`。

   > 示例1：
   >
   > ```c++
   > /* drvimu.cpp */
   > 
   > uint8_t drvimu_dataBuf[14];
   > int16_t drvimu_rawAx,drvimu_rawAy,drvimu_rawAz; 
   > int16_t drvimu_rawGx,drvimu_rawGy,drvimu_rawGz;
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```

2. 局部变量和函数内的静态（`static`）变量直接采用`Camel命名法`。



##### 2.1.3. 前缀与后缀

1. 全局变量的前缀应与文件名或文件名主体保持一致。若文件名太长，可一定程度缩写。前缀一般不少于3字符，不多于8字符。



#### 2.2. 变量的使用

##### 2.2.1. 全局变量

1. 在C++代码中，应避免使用全局变量。在C语言中，也应该谨慎使用全局变量。

2. 避免以全局变量的形式在模块之间传递变量。如要在模块之间传递变量，应该通过传递指针或传递引用的形式。

   > 示例1：
   >
   > `drvimu.hpp`与`drvimu.cpp`是IMU驱动模块，用于读取六轴传感器的三轴加速度、角速度等数据。函数`void DRVIMU_GetAcceData(void)`的功能是读取IMU的三轴加速度。`appctrl.cpp`是控制代码模块，函数`void APPCTRL_urAngCtrl(void);`的作用进行平衡车的角度控制。为了获取车模当前角度，需要读取IMU。
   >
   > ```c++
   > /* drvimu.hpp */
   > //ohter code...
   > extern int16_t drvimu_rawAx, drvimu_rawAy, drvimu_rawAz;
   > 
   > void DRVIMU_GetAcceData(void);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* drvimu.cpp */
   > //ohter code...
   > int16_t drvimu_rawAx,drvimu_rawAy,drvimu_rawAz;
   > 
   > void DRVIMU_GetAcceData(void)
   > {
   >  drvimu_rawAx = DRVIMU_getAx();
   >  drvimu_rawAy = DRVIMU_getAy();
   >  drvimu_rawAz = DRVIMU_getAz();
   > }
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* appctrl.cpp */
   > //ohter code...
   > void APPCTRL_angCtrl(void)
   > {
   >  extern int16_t drvimu_rawAx, drvimu_rawAy, drvimu_rawAz;
   >  DRVIMU_GetAcceData()；
   >  //use these varibles directly here.
   >  //...
   > }
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   >
   > 上述代码就违背了本条规范。我们在模块`drvimu`内定义了相关变量，然后在`appctrl`模块内直接引用了上述变量，逻辑上并没有任何问题。问题在于在IMU的驱动程序完成之前，写控制的人事先并不知道这些变量的名字，而必须在IMU驱动写完后与写IMU驱动的人交流。如果类似的情况频繁发生，写控制的人就不得不就许多变量进行询问，大大降低了开发效率。更可怕的是，如果开发IMU驱动的人更改了变量名称，或是换用了不同人写的不同型号IMU的驱动程序，上层程序将不得不对所有用到这些变量的代码进行修改，工程量之大显而易见。这些损耗都是不必要的，可以通过下面的方式加以避免：
   >
   > 示例2：
   >
   > ```C++
   > /* drvimu.hpp */
   > //ohter code...
   > 
   > void DRVIMU_GetAcceData(int16_t& drvimu_rawAx, int16_t& drvimu_rawAy, int16_t& drvimu_rawAz);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* drvimu.cpp */
   > //ohter code...
   > 
   > void DRVIMU_GetAcceData(int16_t& drvimu_rawAx, int16_t& drvimu_rawAy, int16_t& drvimu_rawAz);
   > {
   >  drvimu_rawAx = DRVIMU_getAx();
   >  drvimu_rawAy = DRVIMU_getAy();
   >  drvimu_rawAz = DRVIMU_getAz();
   > }
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* appctrl.cpp */
   > //ohter code...
   > int16_t appctrl_rawAx, appctrl_rawAy, appctrl_rawAz;
   > 
   > void APPCTRL_angCtrl(void)
   > {
   >  
   >  DRVIMU_GetAcceData(appctrl_rawAx, appctrl_rawAy, appctrl_rawAz)；
   >  //...
   > }
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   > 这种方式完美地规避了前面提到的问题。底层驱动提供的接口需要调用它的上层程序传递给底层驱动变量的引用，这样底层驱动就可以把读到的数据放到上层程序指定的地方。上面的程序基于C++编写，C语言没有“引用”的概念，只需把C++的引用换成C语言的指针即可。实际上，“引用”就是对指针的一次包装。这是我们第一次接触“接口”的概念。接口，可以简单地定义成**“用于访问一类数据的统一方法”**。因此，这条规范也可以写成：**“以函数为接口，而不以变量为接口”**。
   >
   
3. 仅在一个模块内使用的全局变量，推荐在源文件内定义，而不在对应头文件中进行`extern`声明。只有需要外部访问的全局变量，才在头文件中以`extern`修饰声明。

##### 2.2.2. 静态变量

1. 仅在一个函数内使用的全局变量，应该使用函数内的静态（static）变量。
2. 不建议在头文件中定义变量。如果不得不在头文件中定义变量（不加`extern`的情况），则必须以static修饰，且禁止重复包含。这种情况往往出现在一个模块只有头文件、没有对应源文件的情况。
3.  对C++广义类（`class`和`struct`）中的常量和由所有对象共享的属性，应当使用静态成员变量。

##### 2.2.3. 局部变量

##### 2.2.4. 指针与引用

##### 2.2.5. 常量与宏

1. 对于单片机编程，不经特殊处理的情况下，所有常量（字面值和声明值）位于程序存储器。一般来说，MK66、KV58等普通单片机的程序存储器I/O性能弱于随机存储器。在这类单片机上，由于性能考量，即使一个需要频繁访问的变量在逻辑上是常量，也不应该以`const`修饰或使用宏定义。

##### 2.2.6. 枚举类型

1. 对于具有互斥属性或特定含义的一组数据，应该使用枚举类型（`enum`）加以描述。

2. 对于C11或C++11及更新的标准C/++，使用枚举类型（`enum`）时必须指明所用的存储类型。C语言在声明全局枚举类型时，其内部的枚举项必须含有与枚举类型名相同的前缀。C++11及更新标准的C++，在声明全局枚举类型时，必须用`enum class`的形式声明，而不必带有前缀；在声明作用域内的枚举类型时，如果作用域范围较大，也应该使用`enum class`的形式。

   > 示例1：
   >
   > ```c++
   > /* test1.h */
   > //C11 enum
   > #include <stdint.h>
   > enum testC_t: uint8_t
   > {
   > 	testC_A,
   > 	testC_B,
   > 	testC_C,
   > };
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > /* test2.hpp */
   > #include <cstdint>
   > //C++14 global enum class
   > enum class testCpp_t : uint8_t
   > {
   > 	A,
   > 	B,
   > 	C,
   > };
   > 
   > //C++14 regional enum 
   > class myclass
   > {
   > public:
   >     enum testCpp_t : uint8_t
   >     {
   >         A,
   >         B,
   >         C,
   >     };
   > };
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```

###### 2.2.6.1. 常量枚举

1. 当所表示的数据为一系列具有相似含义的数（如某I2C设备的寄存器地址）时，必须采用枚举类型。这种用法称为常量枚举。

   > 示例1：
   >
   > ```c++
   > /** Integration time settings for TCS34725 */
   > typedef enum : uint8_t
   > {
   >   TCS34725_INTEGRATIONTIME_2_4MS =
   >       0xFF, /**<  2.4ms - 1 cycle    - Max Count: 1024  */
   >   TCS34725_INTEGRATIONTIME_24MS =
   >       0xF6, /**<  24ms  - 10 cycles  - Max Count: 10240 */
   >   TCS34725_INTEGRATIONTIME_50MS =
   >       0xEB, /**<  50ms  - 20 cycles  - Max Count: 20480 */
   >   TCS34725_INTEGRATIONTIME_101MS =
   >       0xD5, /**<  101ms - 42 cycles  - Max Count: 43008 */
   >   TCS34725_INTEGRATIONTIME_154MS =
   >       0xC0, /**<  154ms - 64 cycles  - Max Count: 65535 */
   >   TCS34725_INTEGRATIONTIME_700MS =
   >       0x00 /**<  700ms - 256 cycles - Max Count: 65535 */
   > } tcs_integrationTime_t;
   > ```
   >
   > 这是用于表示TCS34725传感器积分时间的寄存器取值的`enum`。

###### 2.2.6.2. 标志位枚举

1. 当所表示的数据为按位表示的逻辑（如某flag的各位代表的含义）时，必须采用枚举类型。这种用呀称为标志位枚举。

   > 示例1：
   >
   > ```c++
   > enum class ctrl_excp_t : uint32_t
   > {
   > 	camLostWay = 1 << 0,
   > 	magLostWay = 1 << 1,
   > 	cam_cross = 1 << 2,
   > 	mag_cross = 1 << 3,
   > 	cam_loopEntry = 1 << 4,
   > 	cam_loopEnter = 1 << 5,
   > 	cam_inLoop = (cam_loopEntry | cam_loopEnter),
   > 	mag_loopEntry = 1 << 6,
   > 	mag_loopEnter = 1 << 7,
   > 	mag_inLoop = (mag_loopEntry | mag_loopEnter),
   > 	loopL = 1 << 8,
   > 	loopR = 1 << 9,
   > 	whichLoop = (loopL | loopR),
   > 	rampRoad = 1 << 10,
   > 	hinder = 1 < 11,
   > 	snapRoad = 1 << 12,
   > 	//add more if needed.
   > };
   > ```
   >
   > 这是一个用于表示各种标志位的`enum class`。



#### 2.3. 变量注释







### 三、 表达式







### 四、 条件语句







### 五、 函数

#### 5.1. 函数命名

##### 5.1.1. 保留函数命名

1. 禁止使用`i`、`j`、`k`、`x`、`y`、`z`、`m`、`n`、`p`、`r`、`c`等具有数学含义、物理含义或现实意义的字母或单词作为函数名。

2. 禁止使用形如`aa`、`bbb`等毫无意义的名称作为函数名。

3. 避免使用形式常被用于系统保留的字符作为函数名，如全部大写（`NAME`）、首尾带下划线（`_name_`、`_name`、`name_`、`__name__`、`__name`、`name__`）。

4. 禁止使用容易误解为变量名的名称作为函数名。

5. 必须规范使用某些具有特定含义的函数名，如下所示：

   > 示例1：
   >
   > ```c++
   > void PREFIX_Init(void);				//initliazation
   > void PREFIX_Setup(void);
   > void PREFIX_Deinit(void);
   > //unfinished.
   > ```
   >
   > Init保留字表示初始化。DeInit保留字表示取消初始化。Setup表示设置，与Init的别是Init往往用于对硬件操作，而Setup用于对内存中的变量进行初始化，而无需硬件操作。

   如果工程内有其他约定的特定含义的符号，也应遵循本条规范。

##### 5.1.2. 一般命名

1. 头文件和源文件中定义的可被外部调用的函数，命名采用`大写前缀`+ `_`+`Pascal命名法`。

   > 示例1：
   >
   > ```c++
   > /* drvimu.cpp */
   > //ohter code...
   > status_t DRVIMU_Init(void);
   > status_t DRVIMU_GetAcceData(int16_t& drvimu_rawAx, int16_t& drvimu_rawAy, int16_t& drvimu_rawAz);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```

2. 头文件和源文件中定义的不可外部调用的函数，命名采用`大写前缀`+ `_`+`Camel命名法`。

   > 示例1：
   >
   > ```c++
   > /* drvimu.hpp */
   > //ohter code...
   > void DRVIMU_getConfig(drvimu_cfg_t& cfg);
   > status_t DRVIMU_i2cRx(uint8_t addr, uint8_t reg, uint16_t size, uint8_t* data);
   > status_t DRVIMU_i2cTx(uint8_t addr, uint8_t reg, uint16_t size, uint8_t* data);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```


##### 5.1.3. 前缀与后缀

1. 函数的前缀应与文件名或文件名主体保持一致。若文件名太长，可一定程度缩写。前缀一般不少于3字符，不多于8字符。

2. 函数可以带有用于说明不同版本或特性的后缀，采用Pascal命名法，以下划线连接。

   > 示例1：
   >
   > ```c++
   > /* drvftm.hpp */
   > //ohter code...
   > void DRVFTM_MotorUpdate(int16_t pwmL, int16_t pwmR);
   > void DRVFTM_MotorUpdate_HiRes(float pwmL, float pwmR);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   >
   > MotorUpdate是用于更新电动机PWM占空比、设置电机功率的函数，有两个版本：普通版本（`MotorUpdate`）接受[-100，100]的整形参数，高精度版本（`MotorUpdate_HiRes`）接受[-100.0,100.0]的浮点参数。



#### 5.2. 函数的使用

##### 5.2.1. 内联函数

1. 当一个函数较短且频繁调用时，建议使用内联函数。内联函数可以节约用于函数跳转的时间，提高执行效率。内联函数的函数体需要写在头文件中。

   > 示例1：
   >
   > ```c++
   > /* drvftm.hpp */
   > //ohter code...
   > inline void DRVFTM_MotorUpdate(int16_t pwmL, int16_t pwmR)
   > {
   >     //...
   > }
   > inline void DRVFTM_MotorUpdate_HiRes(float pwmL, float pwmR)
   > {
   >     //...
   > }
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```

   

##### 5.2.2. 静态函数

1. 当一个函数被频繁调用时，建议使用静态函数。静态函数将永久地驻留内存，使得调用该函数时无需开辟新的栈空间，提高执行效率。

##### 5.2.3. 函数的返回值

1. 必须谨慎使用函数返回值。任何存在异常状态的函数，都必须具有`status_t`类型的返回值，用于表示该函数执行的状态。函数正确执行必须返回0。除非有充分的理由（例如适配器函数等特殊情况 ），否则禁止将函数返回值用于传递结果。如要返回结果，应该在参数中添加用于保存结果的指针或引用。

   > 示例1
   >
   > ```C++
   > /* drvimu.hpp */
   > //ohter code...
   > drvimu_cfg_t DRVIMU_getConfig(void);
   > uint8_t DRVIMU_i2cRxReg(uint8_t addr, uint8_t reg);
   > void DRVIMU_i2cTxReg(uint8_t addr, uint8_t reg, uint8_t data);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   >
   > 上述代码违背了本条规范。
   >
   > 第一个函数用于获得IMU的默认配置，其将一个较大的结构体直接作为函数的返回值。这在一定程度上可以被看作是适配器函数，这样写虽然不推荐但问题不大。
   >
   > 第二个函数用于从IMU的寄存器读取一个字节，它将读取的结果直接作为返回值返回。先不说它与下面的写寄存器函数缺乏对称性，如果I2C读取过程中出现了错误，底层API给出了非0的异常返回值，该函数必须自行处理（事实上这是不可能的），而无法将该错误返回给上层。此时上层函数大概率会得到返回值0，从而无法区分究竟是该函数发生了错误还是该寄存器的值为0。
   >
   > 第三个函数用于向IMU的寄存器写一个字节。这种写法的问题在于无法返回错误，上面已经写得很清楚了，不再赘述。
   >
   > 示例2：
   >
   > ```C++
   > /* drvimu.hpp */
   > //ohter code...
   > void DRVIMU_getConfig(drvimu_cfg_t& cfg);
   > status_t DRVIMU_i2cRxReg(uint8_t addr, uint8_t reg, uint8_t data);
   > status_t DRVIMU_i2cTxReg(uint8_t addr, uint8_t reg, uint8_t data);
   > //ohter code...
   > 
   > /* ---------- ---------- ---------- ---------- */
   > ```
   >
   > 以上是正确示例。


##### 5.2.4. 函数的参数


##### 5.2.5. 函数重载



#### 5.3. 函数注释

1. 注释格式：`@brief`用于说明函数的主要功能；`@param`用于说明各参数的作用。

   > 示例1：
   >
   > ```c++
   > /* fsl_cmp.h */
   > 
   > /*!
   >  * @brief Enables/disables the DMA request for rising/falling events.
   >  *
   >  * This function enables/disables the DMA request for rising/falling events. Either event triggers the generation of
   >  * the DMA request from CMP if the DMA feature is enabled. Both events are ignored for generating the DMA request from the CMP
   >  * if the DMA is disabled.
   >  *
   >  * @param base CMP peripheral base address.
   >  * @param enable Enables or disables the feature.
   >  */
   > void CMP_EnableDMA(CMP_Type *base, bool enable);
   > ```
   >
   > 该示例来自K66的NXP官方SDK。

2. 所有可外部调用的函数必须含有完善的注释。内部函数按需。









### 六、 结构体与类

#### 6.1. 结构体与类命名

##### 6.1.1. 保留命名



##### 6.1.2. 一般命名

1. 全局结构体与类命名采用`小写前缀`+ `_`+`Camel命名法`+`_t`。
2. 作用域内的结构体与类命名采用`Camel命名法`+`_t`。



##### 6.1.3. 成员变量命名







##### 6.1.4. 成员函数命名





#### 6.2. （C语言）结构体的使用

1. 对于C语言中需要创建多个实例的项目，应将每个实例共有的数据结构抽象为结构体，并提供一组函数用于操作这些数据结构。

   > 示例1：
   >
   > 参见K66 MCUXpresso SDK中的各种Handle。

   

#### 6.3. （C++语言）类的使用

1. 对于C++中的任何功能相对独立的模块，创建类以界定其数据结构和方法的作用域。如果能且仅能创建一个实例，使用单件模式。如果能且仅能创建指定个数的实例，使用改进的单件模式（多件模式）。

   > 示例1：单件模式的一种实现
   >
   > ```c++
   > /* app_ui.hpp */
   > 
   > //display HAL
   > class appui_disp_t
   > {
   > public:
   > 	static appui_disp_t& GetInst(void)
   > 	{
   > 		static appui_disp_t inst;
   > 		return inst;
   > 	}
   >     
   > 	//...
   > 
   > private:
   > 	appui_disp_t(void) {}
   > 	appui_disp_t(const appui_disp_t&);
   > 	appui_disp_t& operator = (const appui_disp_t&);
   > };
   > 
   > 
   > ```
   >
   > 首先，将该类的默认构造函数、拷贝构造函数、赋值运算符定义为私有，从而不可能在此类作用于外创建该类的实例。然后创建公有静态函数`static appui_disp_t& appui_disp_t::GetInst(void);`，在此函数内创建静态实例`static appui_disp_t inst`。调用该函数时，永远返回对`inst`的引用。
   >
   > 
   >
   > 示例2：改进的单件模式（多件模式）
   >
   > ```C++
   > /* drv_uartmgr.hpp */
   > 
   > class uartmgr_t
   > {
   > public:
   > 	static uartmgr_t& GetInst(LPUART_Type* instNum)
   > 	{
   > 		static uartmgr_t dbugInst(LPUART1);
   > 		static uartmgr_t wlanInst(LPUART4);
   > 		static uartmgr_t intcInst(LPUART5);
   > 		switch ((uint32_t)instNum)
   > 		{
   > 		case LPUART1_BASE:
   > 			return dbugInst;
   > 			break;
   > 		case LPUART4_BASE:
   > 			return wlanInst;
   > 			break;
   > 		case LPUART5_BASE:
   > 			return intcInst;
   > 			break;
   > 		default:
   > 			return dbugInst;
   > 			break;
   > 		}
   > 		return dbugInst;
   > 	}
   > 	
   > 	//...
   > 
   > private:
   > 
   > 	uartmgr_t(LPUART_Type* _base)
   > 	{
   > 		//...
   > 	}
   > };
   > ```
   >
   > 首先，将该类的默认构造函数、拷贝构造函数、赋值运算符定义为私有，从而不可能在此类作用于外创建该类的实例。然后创建公有静态函数`static uartmgr_t& uartmgr_t::GetInst(LPUART_Type* instNum);`，在此函数内创建三个静态实例。调用该函数时，根据参数永远返回对前述三个静态实例之一的引用。

   

2. 对于C++中的一组具有相似方法的对象，创建纯虚类作为接口。



















### 七、 预编译指令







### 八、 异常处理



## 第二部分 架构规范

